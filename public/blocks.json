[
  {
    "robot": "Arm",
    "type": "start",
    "logic": "const actuator = [\"12kg\", \"12kg\", \"12kg\", \"12kg\"];\nconst\ngainsP = [1, 1, 0.9, 0.9];\nconst gainsD = [0.5, 0.5, 0, 0];\nlet Joints = [];\nconst noOfMotors = actuator.length;\ncom = 0;\nlet angles_start = await(() => {\nreturn new Promise((resolve, reject) => {\nlet com = setInterval(() => {\nconst data = sensorData;\nif (data) {\nclearInterval(com);\nresolve(data);\n}\n}, 100)\n})\n})()\n\nfor (let i = 0; i < noOfMotors; i++) {\nlet current = angles_start.jointData[i].angle;\nangles_start.jointData[i].angle = Math.sign(current) * (Math.floor(Math.abs(current) / 5)) * 5;n}\nfor(let i=0;i<noOfMotors;i++){\nJoints[i]=new ServoMotorsClass(i,actuator[i],angles_start.jointData[i].angle,gainsP[i],gainsD[i]);\n}\nconst actions=new BlockClass();\nconst executeloop = (text) => {\nreturn new Promise((resolve, reject) => {\nconst sensorData = sensorDataRef.current;\nconst unityContext = props.unityContext;\neval(\"(async () => {\" + text + \"})()\").catch((e) => { resolve('')});\nif (codeChanged) { resolve(''); }\n})\n};\ntext = `const angles = sensorData;\nif (angles) {\nlet input = { motors: [] };\nfor (let i = 0; i < noOfMotors; i++) {\ninput.motors.push(Joints[i].Evaluate(angles['jointData'][i].angle,angles['jointData'][i].velocity));\n}\nconst formattedInput = JSON.stringify(input);\nlet robot = new ActuationClass(someVar, RoboticSystemName, formattedInput);\nrobot.run();\n}\nresolve();`\nlet Loop = async () => {\nawait executeloop(text);\nif (codeChanged) {\ncodeChanged = false;\nconsole.log(\"deleted\");\n}\nelse {\ncom = setTimeout(Loop, 10);\n}\n}\nLoop()\n",
    "executes": [],
    "simpleLogic":"IntialiseRobot();",
    "simpleExecutes":""
  },
  {
    "robot": "Player",
    "type": "start",
    "logic": [],
    "executes": "if(sensorData){\n // console.log(sensorData);\nconst rawData=JSON.parse(sensorData);\nconst currentData={};\ncurrentData.speedOf=rawData.obstacleSpeed;\n\tcurrentData.distance=rawData.obstacleDistance.x;\n\tcurrentData.elevationOf=rawData.obstacleDistance.y;\n\tcurrentData.widthOf=rawData.obstacleSize.x;\n\tcurrentData.heightOf=rawData.obstacleSize.y;\n",
    "simpleLogic":"",
    "simpleExecutes":"while(gameIsON){"
  },
  {
    "robot": "Arm",
    "type": "specific",
    "name": "move",
    "inputs": [
      { "variable": "x", "type": "number", "value": 0 },
      { "variable": "y", "type": "number", "value": 0 },
      { "variable": "z", "type": "number", "value": 0 }
    ],
    "logic": "const TargetAngles = actions.InverseKinematics(x, y, z);\nif (TargetAngles) {\nfor (let i = 0; i < noOfJoints; i++) {\nJoints[i].SetAngle(TargetAngles[i]);\n}\n}\nconst rate = 1000;\nconst maxtime = 10;\nconst maxRepeats = maxtime * 1000 / rate;\nlet repeats = 0;\ninterval = setInterval(() => {\nlet Reached = true;\nrepeats++;\nfor (let i = 0; i < noOfJoints; i++) {\nconst error = Math.abs(TargetAngles[i] - sensorData.jointData[i].angle);\nif (error > 5) {\nReached = false;\nbreak;\n}\n}\nif (Reached||repeats>=maxRepeats) {\nclearInterval(interval);\nresolve();\n}\n}, rate);\n"
  },
  {
    "robot": "Arm",
    "type": "specific",
    "name": "gravity",
    "inputs": [{ "variable": "isOn", "type": "boolean", "value": true }],
    "logic": "if(isOn){\n\tprops.unityContext.send(\"GravitySphere\", \"EnableGravitySphere\");\n}else{\n\tprops.unityContext.send(\"GravitySphere\", \"DisableGravitySphere\");\n}\nresolve();\n"
    
  },
  {
    "robot": "Arm",
    "type": "end",
    "logic": [],
    "executes": [],
    "simpleLogic":"",
    "simpleExecutes":""
  },
  {
    "robot": "Player",
    "type": "end",
    "logic": [],
    "executes": "}",
    "simpleLogic":"",
    "simpleExecutes":"}"
  },{
    "name": "delay",
    "type": "specific",
    "inputs": [{ "variable": "a", "type": "number", "value": 0 }],
    "logic": "setTimeout(resolve, a*1000);",
    "executes": "}"
  }
]
